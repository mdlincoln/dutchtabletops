---
title: "Clustering the Dutch Tabletop"
author: "Matthew Lincoln"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r libraries, include = FALSE}
library(dutchtabletops)
library(dplyr)
library(tidyr)
library(stringr)
library(scales)
library(ggplot2)
library(cluster)
library(knitr)
library(threejs)
library(purrr)
library(DT)
library(ggrepel)
opts_chunk$set(message = FALSE, warning = FALSE, cache = FALSE, fig.width = 7, fig.height = 6)
```

Let's take a look at some of the basic dimensions of this dataset:

```{r basic_metrics}
# Major artists
dt_paintings %>% 
  count(artist, sort = TRUE) %>% 
  mutate(artist = c(artist[1:10], rep("other", length(artist) - 10))) %>% 
  group_by(artist) %>% 
  summarize(n = sum(n)) %>% 
  arrange(desc(n)) %>% 
  kable()
```

```{r}
# Thematic formats
dt_paintings %>% 
  count(thematic_format, sort = TRUE) %>% 
  kable()
```

- Can probably reduce the number different categories

```{r}
# Compositional Format
dt_paintings %>% 
  count(compositional_format, sort = TRUE) %>% 
  kable()

# Compositional disposition
dt_paintings %>% 
  count(compositional_disposition, sort = TRUE) %>% 
  kable()

# Compositional cropping
dt_paintings %>% 
  count(compositional_cropping, sort = TRUE) %>% 
  kable()

# Compositional viewpoint
dt_paintings %>% 
  count(compositional_viewpoint, sort = TRUE) %>% 
  kable()

# Dimensions
ggplot(dt_paintings, aes(x = width, y = height, color = compositional_format)) + 
  geom_point() + 
  annotate("segment", x = 0, y = 0, xend = 300, yend = 300) + 
  xlim(0, 225) + ylim(0, 225)

# Distribution of works in time
ggplot(dt_paintings, aes(x = year)) + geom_histogram()
```

Note that, at the moment, paintings coded as early, mid, late, etc. are all grouped into the one year that they reference.
This could be handled more deftly.

## The experiment

- Do certain artists have oeuvres that are more stylistically close, or distant? More iconographically close or distant?
- Do the groups of paintings that emerge when clustered based on their stylistic attributes align with those clustered based on iconographic attributes?
- Do relationships between certain motifs and styles change over time?

To determine this, we can cluster by each set of variables, and then compare the agreement of these clusters.

## Clustering Motifs

What groups do these paintings fall in to based on the motifs within them?

To calculate a motif distance between objects, identify how many shared motifs there are between each object.
This is easily done by generating a table with a column for each motif, marking its presence or absence for a given row (object).
From this, we can calculate an easy dissimilarity matrix calculating manhattan block distance.

This can also later be enahnced with hierarchical information.
For example, Item with motif `AC1` would have a mark for `A`, `AC`, and `AC1`, granting it some shared similarity to an object with `AC2`, and even to object with `AB3`.

```{r motif_hierarchy, eval=FALSE}
# An example of what this hierarchy looks like in practice:
dt_paintings %>% 
  filter(painting_code == "FvS 29") %>% 
  inner_join(dt_painting_motifs, by = "painting_code") %>% 
  inner_join(dt_motif_taxonomy, by = "motif_code") %>% 
  inner_join(dt_motif_labels, by = "motif_code") %>% 
  select(painting_code, motif_code = parent, motif_label) %>% 
  filter(!is.na(motif_code)) %>% 
  knitr::kable()
```

With a hierarchy defined, we now create a table with one row per object, one colum per motif.
Each cell is `TRUE`/`FALSE`.
From this boolean matrix, we can calculate the multidimensional distance between each row; a prerequisite to applying clustering techniques.s

```{r motifs_per_object, eval=FALSE}
motif_data <- dt_painting_motifs %>% 
  left_join(dt_motif_taxonomy, by = "motif_code") %>% 
  mutate(parent = ifelse(is.na(parent), motif_code, parent)) %>% 
  select(-motif_code) %>% 
  mutate(is_present = TRUE) %>%
  distinct() %>% 
  spread(key = parent, value = is_present, fill = FALSE, drop = FALSE)

motif_matrix <- motif_data %>% select(-painting_code) %>% data.matrix()
rownames(motif_matrix) <- motif_data$painting_code
```

We want to treat the existence/non-existence of a given motif as _binary_.
The variable is binary because, at least in this current encoding, the painting either has the motif (and its ancestors), or it does not.
However, we need to distinguish between _symmetric_ or _asymmetric_ binary.
A binary variable is symmetric when either the presence or the absence of that trait tells you something meaningful about the class of objects that share it.
If we treat motif presence as symmetric, this means that we would consider true two statements:

1. Paintings that all feature a human skull comprise a meaningful group, 
2. Paintings that _do not_ feature a human skull are also a meaningful group.

Both presence and absence are thus equally weighted when judging how close or distant two objects are within the motif space.
On the other hand, a binary variable is asymmetric when its presence tells you more than its absence.
E.g. paitings that all feature human skulls are a meaningful group, but paintings that do not feature a human skull may not have much else in common.[^symmnote]

I would provisionally argue that motifs are an asymmetric binary variable.
Just because a set of paintings lack an hourglass does not tell us anything meaningful about their set as a whole.
That said, one might argue that absence can be as meaningful as presence, particularly with regards to _vanitas_ motifs.
We can certainly compare the results of treating motif presence as symmetric and also asymmetric.
It is also possible (at the cost of introducing a lot more arbitrary decision making) to code certain motifs as symmetric, and certain motifs as asymmetric.

[^symmnote]: See ["Symmetric versus Asymmetric Nominal Variables"](http://support.sas.com/documentation/cdl/en/statug/63033/HTML/default/viewer.htm#statug_distance_sect003.htm)

```{r motif_dist}
motif_dist <- dist(motif_matrix, method = "euclidean")
motif_clust <- hclust(motif_dist)

```

Principal component analysis is another way to visualize these clusterings.

```{r motif_pca}
prin <- prcomp(motif_matrix, scale. = TRUE)
tpca_projection <- predict(prin, newdata = motif_matrix)

# just project into the first 2dis PCA axes
pca_df <- as.data.frame(tpca_projection[,1:3])
pca_df$painting_code <- rownames(pca_df)
pca_df <- pca_df %>% inner_join(dt_paintings, by = "painting_code")

motif_load <- as.data.frame(scale(prin$rotation[,1:2])) %>% 
  mutate(
    motif_code = rownames(.),
    magnitude = sqrt(PC1^2 + PC2^2)) %>% 
  top_n(20, magnitude)

ggplot(pca_df, aes(x = PC1, y = PC2)) +
  geom_point(size = 5, alpha = 0.5) +
  geom_segment(data = motif_load, aes(xend = 0, yend = 0), color = "red") +
  geom_text_repel(data = motif_load, aes(label = motif_code)) +
  theme_bw() +
  theme(legend.position = "bottom")
```

How much weight does a given motif have in the principal component?
This "variable loading" suggests which motifs are a strong determining factor in creating clusterings.

Which motifs tend to show up in just one set of artworks?

```{r motif_pca_loadings, eval=FALSE}
loadings <- pca$rotation %>% 
  as.data.frame() %>% 
  mutate(code = rownames(pca$rotation), l1 = abs(PC1))

loadings %>% 
  top_n(16, l1) %>% 
  select(code, l1) %>% 
  kable()
```

Which motifs have the lowest loadings, and tend to show up just about anywhere?

```{r, eval=FALSE}
loadings %>% 
  top_n(16, desc(l1)) %>% 
  select(code, l1) %>% 
  kable()
```

These data are $N$-dimensional (or, in our case specifically, 254-dimensional); but each additional dimension has less and less power.
Above are projected the first two dimensions.
We can do 3 as well (colored by clustered group):

```{r motif_pca3d, cache=FALSE, eval=FALSE}
scatterplot3js(
  pca_df$PC1, 
  pca_df$PC2, 
  pca_df$PC3, 
  color = col_factor(hue_pal()(6), domain = NULL)(pca_df$cluster),
  labels = motif_data$label,
  renderer = "canvas",
  stroke = NULL)
```

Needed improvements:

- The way that I've induced a hierarchy from the coding system is flawed, as it assumes that each character signifies a new level, whereas some levels have a two-character abbreviation. This is pretty easy to fix.
- Not all the artworks have been consistently tagged. Any use of `XXX and XXX` instead of `XXX; XXX; XXX` croaks my parser. This is only 30-something artworks, so easily fixable.
- Let's get a table mapping full labels to each abbreviated code.
- We also don't want to run just one cluster, but instead run it many times to see which clusters are _stable_ (constantly reappearing) and which are fugitive. This can be done with `clusterboot()`

```{r motif_clusterboot, eval=FALSE}
library(fpc)
n_clust <- 6
boot_clust <- clusterboot(asymm_motif_dist, clustermethod = hclustCBI, method = "ward.D2", k = n_clust, count = FALSE)
summary(boot_clust$result)
cluster_stability <- data_frame(cluster = 1:n_clust, stability = boot_clust$bootmean)
```

```{r motif_clusterboot_plot, eval=FALSE}
pca_df %>% 
  mutate(cluster = boot_clust$partition) %>% 
  inner_join(cluster_stability, by = "cluster") %>% 
  ggplot(aes(x = PC1, y = PC2, color = as.factor(cluster), alpha = stability > 0.6)) +
  geom_point(size = 5) +
  theme_bw() +
  theme(legend.position = "bottom")
```

